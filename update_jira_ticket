#!/usr/bin/env ruby

require 'net/http'
require 'json'
require 'uri'
require 'base64'

# Script to update Jira ticket status, assignee, and other fields
# Usage: script/update_jira_ticket TICKET-123 [options]
# Requires JIRA_ACCESS_TOKEN environment variable to be set

class JiraTicketUpdater
  def initialize
    @access_token = ENV['JIRA_ACCESS_TOKEN']
    @jira_email = ENV['JIRA_EMAIL'] || 'abeckwith@zendesk.com'
    @jira_base_url = 'https://zendesk.atlassian.net'

    if @access_token.nil? || @access_token.empty?
      puts 'Error: JIRA_ACCESS_TOKEN environment variable is not set'
      exit 1
    end

    # @jira_email now has a fallback, so no need to exit if ENV var is not set
    puts "Using JIRA email: #{@jira_email}" if ENV['DEBUG']
  end

  def update_ticket(ticket_key, options = {})
    ticket_key = ticket_key.upcase

    # Build the update payload
    update_fields = {}

    # Handle assignee update
    if options[:assignee]
      if options[:assignee].downcase == 'me' || options[:assignee] == @jira_email
        # Get my account ID for assignment
        my_account_id = get_my_account_id
        update_fields[:assignee] = { accountId: my_account_id } if my_account_id
      else
        # For other users, try to get their account ID by email
        account_id = get_account_id_by_email(options[:assignee])
        update_fields[:assignee] = { accountId: account_id } if account_id
      end
    end

    # Handle sprint assignment
    if options[:sprint]
      if options[:sprint].downcase == 'current'
        sprint_id = get_current_active_sprint
        if sprint_id
          # Sprint field for this Jira instance
          update_fields[:customfield_10009] = sprint_id
        else
          puts "Warning: No active sprint found"
        end
      else
        update_fields[:customfield_10009] = options[:sprint].to_i
      end
    end

    # Handle status transition
    transition_id = nil
    if options[:status]
      transition_id = get_transition_id(ticket_key, options[:status])
      unless transition_id
        puts "Error: Unable to transition to status '#{options[:status]}'"
        exit 1
      end
    end

    # Update fields if any
    unless update_fields.empty?
      update_ticket_fields(ticket_key, update_fields)
    end

    # Transition status if specified
    if transition_id
      transition_ticket(ticket_key, transition_id)
    end

    puts "Ticket #{ticket_key} updated successfully!"
    puts "View at: #{@jira_base_url}/browse/#{ticket_key}"
  end

  def mark_ready_for_review(ticket_key, assignee = nil)
    assignee ||= @jira_email

    options = {
      assignee: assignee,
      status: 'Ready for Review'
    }

    puts "Marking #{ticket_key} as Ready for Review and assigning to #{assignee}..."
    update_ticket(ticket_key, options)
  end

  private

  def get_current_active_sprint
    # Get the board ID for the project using hardcoded mapping
    board_info = get_board_info_for_project('EM')
    return nil unless board_info
    
    board_id = board_info[:id]
    board_type = board_info[:type]
    
    # Kanban boards don't support sprints
    if board_type == 'kanban'
      puts "Warning: Project uses Kanban board which doesn't support sprints"
      return nil
    end

    uri = URI("#{@jira_base_url}/rest/agile/1.0/board/#{board_id}/sprint?state=active")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'

    begin
      response = http.request(request)

      case response.code
      when '200'
        sprints_data = JSON.parse(response.body)
        active_sprints = sprints_data['values'].select { |sprint| sprint['state'] == 'active' }

        if active_sprints.any?
          return active_sprints.first['id']
        else
          puts "No active sprint found for board #{board_id}"
          return nil
        end
      else
        puts "Error getting active sprint: HTTP #{response.code}"
        return nil
      end
    rescue StandardError => e
      puts "Error getting active sprint: #{e.message}"
      return nil
    end
  end

  def get_board_for_project(project_key)
    # This is a simplified implementation that gets the first board for the project
    # In a real scenario, you might want to configure specific board IDs
    board_info = get_board_for_project_with_type(project_key)
    return board_info ? board_info[:id] : nil
  end

  def get_my_account_id
    # Hardcode my account ID for performance, or fetch it dynamically
    return '557058:07381840-3d1a-4550-9471-c35b6b77ab9d' if @jira_email == 'abeckwith@zendesk.com'
    
    # Fallback to API call
    uri = URI("#{@jira_base_url}/rest/api/3/myself")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    
    request = Net::HTTP::Get.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'
    
    begin
      response = http.request(request)
      if response.code == '200'
        user_data = JSON.parse(response.body)
        return user_data['accountId']
      else
        puts "Error getting account ID: HTTP #{response.code}"
        return nil
      end
    rescue StandardError => e
      puts "Error getting account ID: #{e.message}"
      return nil
    end
  end

  def get_account_id_by_email(email)
    # This could be implemented to search for users by email
    # For now, return nil to indicate we can't find the account ID
    puts "Warning: Cannot resolve account ID for email #{email}. Use accountId directly instead."
    return nil
  end

  def get_board_info_for_project(project_key)
    # Hardcoded board mappings for known projects
    board_mappings = {
      'EM' => { id: 3170, name: 'Email Processing', type: 'scrum' }
      # Add more project mappings as needed
    }
    
    if board_mappings.key?(project_key)
      return board_mappings[project_key]
    end
    
    # Fallback to API discovery if not in hardcoded mappings
    return get_board_for_project_with_type(project_key)
  end

  def get_board_for_project_with_type(project_key)
    # This method returns both board ID and type via API discovery
    uri = URI("#{@jira_base_url}/rest/agile/1.0/board?projectKeyOrId=#{project_key}")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'

    begin
      response = http.request(request)

      case response.code
      when '200'
        boards_data = JSON.parse(response.body)
        if boards_data['values'].any?
          first_board = boards_data['values'].first
          return {
            id: first_board['id'],
            type: first_board['type']
          }
        else
          puts "No boards found for project #{project_key}"
          return nil
        end
      else
        puts "Error getting board for project: HTTP #{response.code}"
        return nil
      end
    rescue StandardError => e
      puts "Error getting board for project: #{e.message}"
      return nil
    end
  end

  def update_ticket_fields(ticket_key, fields)
    uri = URI("#{@jira_base_url}/rest/api/3/issue/#{ticket_key}")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Put.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'
    request['Content-Type'] = 'application/json'

    payload = { fields: fields }
    request.body = payload.to_json

    begin
      response = http.request(request)

      case response.code
      when '204'
        # Success - no content returned
        return true
      when '400'
        puts 'Error: Bad request when updating ticket fields:'
        puts JSON.pretty_generate(JSON.parse(response.body))
        return false
      when '401'
        puts 'Error: Authentication failed. Please check your JIRA_ACCESS_TOKEN'
        return false
      when '403'
        puts 'Error: Permission denied. You may not have permission to update this ticket'
        return false
      when '404'
        puts "Error: Ticket #{ticket_key} not found"
        return false
      else
        puts "Error: HTTP #{response.code} - #{response.message}"
        puts response.body
        return false
      end
    rescue StandardError => e
      puts "Error updating ticket fields: #{e.message}"
      return false
    end
  end

  def get_transition_id(ticket_key, status_name)
    uri = URI("#{@jira_base_url}/rest/api/3/issue/#{ticket_key}/transitions")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'

    begin
      response = http.request(request)

      case response.code
      when '200'
        transitions = JSON.parse(response.body)['transitions']

        # Find transition by name (case-insensitive)
        transition = transitions.find do |t| 
          t['to']['name'].downcase == status_name.downcase ||
          t['name'].downcase == status_name.downcase
        end

        if transition
          return transition['id']
        else
          puts "Available transitions:"
          transitions.each do |t|
            puts "  - #{t['name']} (to: #{t['to']['name']})"
          end
          return nil
        end
      else
        puts "Error getting transitions: HTTP #{response.code}"
        return nil
      end
    rescue StandardError => e
      puts "Error getting transitions: #{e.message}"
      return nil
    end
  end

  def transition_ticket(ticket_key, transition_id)
    uri = URI("#{@jira_base_url}/rest/api/3/issue/#{ticket_key}/transitions")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Post.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'
    request['Content-Type'] = 'application/json'

    payload = {
      transition: {
        id: transition_id
      }
    }
    request.body = payload.to_json

    begin
      response = http.request(request)

      case response.code
      when '204'
        return true
      when '400'
        puts 'Error: Bad request when transitioning ticket:'
        puts JSON.pretty_generate(JSON.parse(response.body))
        return false
      when '401'
        puts 'Error: Authentication failed. Please check your JIRA_ACCESS_TOKEN'
        return false
      when '403'
        puts 'Error: Permission denied. You may not have permission to transition this ticket'
        return false
      when '404'
        puts "Error: Ticket #{ticket_key} not found"
        return false
      else
        puts "Error: HTTP #{response.code} - #{response.message}"
        puts response.body
        return false
      end
    rescue StandardError => e
      puts "Error transitioning ticket: #{e.message}"
      return false
    end
  end
end

# Main execution
if ARGV.empty?
  puts "Usage: #{$0} TICKET-KEY [options]"
  puts "       #{$0} TICKET-KEY --ready-for-review [assignee]"
  puts "       #{$0} TICKET-KEY --assignee user@example.com"
  puts "       #{$0} TICKET-KEY --status 'Ready for Review'"
  puts "       #{$0} TICKET-KEY --sprint current|SPRINT_ID"
  puts ""
  puts "Examples:"
  puts "  #{$0} EM-1234 --ready-for-review"
  puts "  #{$0} EM-1234 --ready-for-review me"
  puts "  #{$0} EM-1234 --ready-for-review john@example.com"
  puts "  #{$0} EM-1234 --assignee me --status 'In Progress'"
  puts "  #{$0} EM-1234 --assignee me --status 'In Progress' --sprint current"
  puts "  #{$0} EM-1234 --sprint 123"
  puts ""
  puts "Environment variables required:"
  puts "  JIRA_ACCESS_TOKEN - Your Jira API token"
  puts "  JIRA_EMAIL - Your Jira email address"
  exit 1
end

ticket_key = ARGV[0]
updater = JiraTicketUpdater.new

# Parse command line arguments
if ARGV.include?('--ready-for-review')
  assignee_index = ARGV.index('--ready-for-review') + 1
  assignee = (assignee_index < ARGV.length) ? ARGV[assignee_index] : nil
  updater.mark_ready_for_review(ticket_key, assignee)
else
  options = {}

  # Parse assignee
  if (assignee_index = ARGV.index('--assignee'))
    assignee_value = ARGV[assignee_index + 1]
    options[:assignee] = assignee_value if assignee_value
  end

  # Parse status
  if (status_index = ARGV.index('--status'))
    status_value = ARGV[status_index + 1]
    options[:status] = status_value if status_value
  end

  # Parse sprint
  if (sprint_index = ARGV.index('--sprint'))
    sprint_value = ARGV[sprint_index + 1]
    options[:sprint] = sprint_value if sprint_value
  end

  if options.empty?
    puts "No update options specified. Use --help for usage information."
    exit 1
  end

  updater.update_ticket(ticket_key, options)
end