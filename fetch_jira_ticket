#!/usr/bin/env ruby

require 'net/http'
require 'json'
require 'uri'
require 'base64'

# Script to fetch Jira ticket information
# Usage: script/fetch_jira_ticket TICKET-123
# Requires JIRA_ACCESS_TOKEN environment variable to be set

class JiraTicketFetcher
  def initialize
    @access_token = ENV['JIRA_ACCESS_TOKEN']
    @jira_email = 'abeckwith@zendesk.com'
    @jira_base_url = 'https://zendesk.atlassian.net'

    if @access_token.nil? || @access_token.empty?
      puts 'Error: JIRA_ACCESS_TOKEN environment variable is not set'
      exit 1
    end

    if @jira_email.nil? || @jira_email.empty?
      puts 'Error: JIRA_EMAIL environment variable is not set'
      exit 1
    end
  end

  def fetch_ticket(ticket_key)
    ticket_key = ticket_key.upcase

    uri = URI("#{@jira_base_url}/rest/api/3/issue/#{ticket_key}")

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri)
    credentials = Base64.strict_encode64("#{@jira_email}:#{@access_token}")
    request['Authorization'] = "Basic #{credentials}"
    request['Accept'] = 'application/json'

    begin
      response = http.request(request)

      case response.code
      when '200'
        ticket_data = JSON.parse(response.body)
        display_ticket_info(ticket_data)
      when '401'
        puts 'Error: Authentication failed. Please check your JIRA_ACCESS_TOKEN'
        exit 1
      when '404'
        puts "Error: Ticket #{ticket_key} not found"
        exit 1
      else
        puts "Error: HTTP #{response.code} - #{response.message}"
        puts response.body
        exit 1
      end
    rescue StandardError => e
      puts "Error fetching ticket: #{e.message}"
      exit 1
    end
  end

  private

  def display_ticket_info(ticket_data)
    fields = ticket_data['fields']

    puts '=' * 80
    puts "JIRA TICKET: #{ticket_data['key']}"
    puts '=' * 80

    puts "\nBASIC INFORMATION:"
    puts "Title: #{fields['summary']}"
    puts "Status: #{fields['status']['name']}"
    puts "Type: #{fields['issuetype']['name']}"
    puts "Priority: #{fields['priority'] ? fields['priority']['name'] : 'None'}"
    puts "Reporter: #{fields['reporter'] ? fields['reporter']['displayName'] : 'Unknown'}"
    puts "Assignee: #{fields['assignee'] ? fields['assignee']['displayName'] : 'Unassigned'}"
    puts "Created: #{format_date(fields['created'])}"
    puts "Updated: #{format_date(fields['updated'])}"

    if fields['project']
      puts "Project: #{fields['project']['name']} (#{fields['project']['key']})"
    end

    if fields['components'] && !fields['components'].empty?
      components = fields['components'].map { |c| c['name'] }.join(', ')
      puts "Components: #{components}"
    end

    if fields['labels'] && !fields['labels'].empty?
      puts "Labels: #{fields['labels'].join(', ')}"
    end

    if fields['fixVersions'] && !fields['fixVersions'].empty?
      versions = fields['fixVersions'].map { |v| v['name'] }.join(', ')
      puts "Fix Versions: #{versions}"
    end

    puts "\nDESCRIPTION:"
    puts '-' * 40
    if fields['description']
      description = extract_text_from_adf(fields['description'])
      puts description.empty? ? 'No description provided' : description
    else
      puts 'No description provided'
    end

    # Comments
    if ticket_data['fields']['comment'] && ticket_data['fields']['comment']['comments']
      comments = ticket_data['fields']['comment']['comments']
      if comments.any?
        puts "\nCOMMENTS (#{comments.length}):"
        puts '-' * 40
        comments.last(3).each_with_index do |comment, index|
          author = comment['author'] ? comment['author']['displayName'] : 'Unknown'
          created = format_date(comment['created'])
          body = extract_text_from_adf(comment['body'])

          puts "[#{created}] #{author}:"
          puts body
          puts '' unless index == comments.length - 1
        end

        if comments.length > 3
          puts "(Showing last 3 comments out of #{comments.length} total)"
        end
      end
    end

    puts "\n" + ('=' * 80)
    puts "URL: #{@jira_base_url}/browse/#{ticket_data['key']}"
    puts '=' * 80
  end

  def format_date(date_string)
    return 'Unknown' unless date_string

    begin
      date = Time.parse(date_string)
      date.strftime('%Y-%m-%d %H:%M:%S %Z')
    rescue
      date_string
    end
  end

  def extract_text_from_adf(adf_content)
    return '' unless adf_content.is_a?(Hash)

    lines = []
    extract_formatted_text_recursive(adf_content, lines, 0)
    lines.join("\n").strip
  end

  def extract_formatted_text_recursive(node, lines, indent_level)
    return unless node.is_a?(Hash)

    case node['type']
    when 'doc'
      # Process document content
      if node['content'].is_a?(Array)
        node['content'].each do |child|
          extract_formatted_text_recursive(child, lines, indent_level)
        end
      end
    when 'heading'
      level = node['attrs'] ? node['attrs']['level'] : 1
      heading_text = extract_plain_text(node)
      prefix = '#' * level
      lines << "#{prefix} #{heading_text}"
      lines << ""
    when 'paragraph'
      text = extract_plain_text(node)
      unless text.empty?
        indent = '  ' * indent_level
        lines << "#{indent}#{text}"
      end
    when 'bulletList'
      if node['content'].is_a?(Array)
        node['content'].each do |list_item|
          extract_formatted_text_recursive(list_item, lines, indent_level)
        end
      end
      lines << "" if indent_level == 0 # Add spacing after top-level lists
    when 'listItem'
      if node['content'].is_a?(Array)
        # First item should be the main text
        first_item = node['content'].first
        if first_item && first_item['type'] == 'paragraph'
          text = extract_plain_text(first_item)
          indent = '  ' * indent_level
          lines << "#{indent}â€¢ #{text}"
        end
        
        # Process any nested content (like nested lists)
        node['content'][1..-1]&.each do |child|
          extract_formatted_text_recursive(child, lines, indent_level + 1)
        end
      end
    else
      # For other node types, just extract text
      if node['content'].is_a?(Array)
        node['content'].each do |child|
          extract_formatted_text_recursive(child, lines, indent_level)
        end
      end
    end
  end

  def extract_plain_text(node)
    return '' unless node.is_a?(Hash)

    text = []
    extract_text_recursive(node, text)
    text.join(' ').strip
  end

  def extract_text_recursive(node, text_array)
    return unless node.is_a?(Hash)

    if node['text']
      text_array << node['text']
    end

    if node['content'].is_a?(Array)
      node['content'].each do |child|
        extract_text_recursive(child, text_array)
      end
    end
  end
end

# Main execution
if ARGV.empty?
  puts "Usage: #{$0} TICKET-KEY"
  puts "Example: #{$0} TALK-1234"
  puts ''
  puts 'Environment variables required:'
  puts '  JIRA_ACCESS_TOKEN - Your Jira API token'
  puts '  JIRA_EMAIL - Your Jira email address'
  puts '  JIRA_BASE_URL - Jira instance URL (optional, defaults to https://zendesk.atlassian.net)'
  exit 1
end

ticket_key = ARGV[0]
fetcher = JiraTicketFetcher.new
fetcher.fetch_ticket(ticket_key)

